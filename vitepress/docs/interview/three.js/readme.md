# WEBGL
- 3d渲染的技术

# three.js
`郭隆邦`
- 3D类库
- 擅长webgl的场景渲染，灵活、原生、自由度高
- 不擅长物理碰撞
- 应用场景
  - 3d数据的可视化
  - 720度产品展示


# 文件格式是由打包方式决定

- gltf
- 自动渲染一个canvas
- 官网的例子调动


## 技术名称
- 场景(scene)
- 相机(camear)
- 渲染器(renderer)
- 几何体
- 材质
- 纹理
- 网格
- 光源
- 视椎

# 极速零配置Web应用打包工具——parcel
- 运行编译某个文件


# 实现流程
- 最重要的就是glft文件，通过api调了我们就可以对车材质（轮毂，车身，前脸，引擎盖，挡风玻璃）进行渲染
- 渲染则是通过`requestAnimationFrame(render);// 递归循环执行`
- 包括弄清楚相机，渲染器，光源几个重要的概念和使用，官方文档还是比较详细的
- 单独实现的起来还是不难的，主要是实现了，我们还是要考虑性能优化的，
- 在网联平台，我们有大量的echarts表格要进行渲染，首页的请求发送有十多条，渲染也要占据大量的处理器资源
- 并且本来我们的模型就是占Cpu和显卡，这个时候我们就需要针对做优化
  - 本质的原因：
    - 骨架屏，延后展示
    - `合适的模型和纹理质量`，因为出现在页面上是一块，我们考虑降级处理
  - 代码优化：
    - 渲染:本来threejs就是基于WEBGL，我们不使用传统的CUP渲染，调用WebGL渲染器和用requestAnimationFrame
    - 批量渲染，和LOD渲染（距离区别模型的质量）
  - 玩一玩Web Works api,就是起另一个线程执行，不会影响我们的主线程，
    - 缺陷也是很明显，我们性能要求高，兼容性也需要去考虑
    - 还有就是OffsreenCavas，是一个可以脱离屏幕渲染的canvas对象，在web works环境是可以使用的
  - Stats.js专门检测渲染帧率


