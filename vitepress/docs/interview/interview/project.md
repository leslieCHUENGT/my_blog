# 前端监控平台

## 介绍一下架构
- 多平台、可拓展、可插拔
- 公共库包 -> 不同平台（wx、h5、pc）-> 独立仓库 -> 功能目录进行增删改
- 为什么要这样设计？
  - 引用api的不同 -> 独立 -> 减少打包体积
  - 公共库 -> 统一公共方法（错误id的生成）
## 异常隔离
- try-catch | jest -> 定位和保证
## 上报优化的降级上报机制
- beacon Api -> 不阻塞 && 不需要响应
## 会话级别的错误上报去重
- 错误栈堆 -> hash -> 临时变量 -> 一个用户一个记录 -> 服务端id处理去重
## 缓存命中率的监控
- performance -> resouce -> 遍历 -> 字段判断
- 插曲 问题 -> 获取 请求耗时/内容下载耗时 -> 跨域问题 `（Timing-Allow-Origin）` 
- 兼容考虑 
- 后续 需求 -> 内存缓存 -> back/forward cache -> 渲染监控
- bf cache兼容性的考量 -> safari/火狐/Chrome -> try-catch

# 性能优化
- url -> 显示 -> 链路
- 网络
  - DNS预解析 （用户必经、必须得静态资源） <link>
  - 缓存策略
  - 预加载 <link>
  - Http2.0
  - CDN（内容分发网络）
  - 资源压缩 gzip
  - SSR策略
- 渲染
  - 重绘重排
  - 动画效果 GPU加速
- js
  - idea空闲 
  - web worker 
  - 内存泄漏
- 工程化/组件化
  - 图片、js、css压缩
  - 产物拆包 （vite内置）
  - 组件复用
  - 懒加载组件
  - 懒加载图片

# 实习难点亮点
- 实际上整个实习过程中是没有什么说特别难的，因为做很多东西都是有迹可循的，可以去借鉴的
- 但是就最近做的特殊情况下首屏计时的问题，是自己比较感兴趣，主动承担的去做的
- 背景就是通过performance面板录制发现这边对于大量Echarts和threejs这种使用 performance api计时不够准确
- lcp失效了，需要手动去进行确切的监控，必须满足 2.5s内的体验时机，所以要确定几个事情

- 怎么监听？
  - 很明显有比较适合的 api ，MutationObserver去进行监听，但是它不能知道什么时候绘制完成，我们只能在每次它Dom改变的时候进行执行回调函数去判断是否可以去进行上报了，但是每次变化又实在太多函数同时进行了
- 希望性能上不要太差，怎么尽量减少对页面的影响？
  - 防抖
- 什么时候开始去上报？
  - 无论怎么样还是需要去进行下载和绘制的，我们可以去对 `DOMContentLoaded`事件、`Lcp`事件的结束获取到他们的状态，然后就可以进行上报了
- 实际上基本都做完了，但是针对这个DOM如果不在首页呢？还是需要去，先去判断一下
- 但是发现还是和录制的结果有差异，会在绘制之前就进行上报，那实际上就是`lcp`的时机不够准确
- 那怎么去进行更精细的统计，主要矛盾就在这绘制的一帧上的问题，因次考虑去用到这个`requestAnimationFrame()`里面调用`performance.now()`
- 还得减去防抖的时间

# threejs优化
- 背景：大量Echarts
- 优化的角度：
  - 业务方，产品方的允许的方案（要有割舍）、出具体的方案来进行讨论
- 矛盾点在于
- 


# 脚手架
- 为什么做这个事情？
  - 因为整车部门很多项目都是一样的、类似的，为了节省后续搭建系统的成本，于是需要一个脚手架和文档来进行快速搭建
- 是什么？完成了什么？
  - PC端、h5端、uniapp、vue、js、ts、权限管理方案、集成基本的埋点和性能监控的选择
  - 负责把PC端的抽象出来，其中要配合产品、后端、Ui来实现整个功能
  - 具体完成的事情：
    - 为了兼容大系统，我们一是进行了传统token的权限管理方式
    - 二是搭建新系统，且权限管理不复杂，我们采取 JWT 的方式进行权限管理

- 背景
  - 为什么？  类似 节约成本 根据之前的项目去抽象出来 统一包版本
- 难点？解决的事情？
  - 脚手架本身没有什么难点，核心就是 `gitClone`，借助 `Node.js`的一些包来实现更优雅的管理，后续还可能增加其他类型的项目的抽象
  - 然后我就讲一讲怎么当初完成这个需求前，和后端、产品、mt怎么讲述要点的吧
  - 1. 模板集成基本的代码格式、提交规范和保证兼容性的方法
  - 2. 项目目录的优化
    - 接口前缀的解耦和统一维护：
      - 微服务架构 -> 分开部署 -> 每个模块功能的接口域名前缀基本不同
  - 3. 报表和按钮的鉴权的实现
    - `怎么用传统双token实现？不用 jwt、session？`
    - `jwt/session适合什么场景？`
    - `权限管理的具体实现`
  - 4. 基本的数据的埋点是怎么做的？
    - pv、uv、路由
    - 优化了路由的埋点方式...
    - 解决实际情况下，飞书进入和 pc系统进入的埋点区别
      - 主要是后端进行发送预警信息，而我们讨论不希望直接将 `token`外显，而是给予了一个未过期的`refresh token`的形式发送，再获取真实 token
  - 5. 后端怎么考虑的，实现的？
    - jwt的产生？
    - 



# 怎么优化？前后端的角度


后端优化：
- 数据库索引：`对频繁查询的字段建立索引`，加快数据库查询速度。

- 缓存数据：使用缓存技术（如 Memcached、`Redis`）缓存热点数据，`减少对数据库的访问`，提高响应速度。

- 优化 SQL 查询：避免使用 SELECT *，只选择需要的字段；合理使用 JOIN、WHERE、GROUP BY 等语句优化查询效率。

- `分页`查询：对于大量数据的查询结果，使用分页查询，减少一次性加载的数据量。

- 异步处理任务：将耗时的任务（如邮件发送、文件处理）放入消息队列或者异步任务队列中处理，减少用户请求的等待时间。

- 水平扩展：使用`负载均衡`和`分布式架构`，将流量分散到多台服务器上，提高系统的`并发`处理能力。
周   
- 监控和调优：使用监控工具对系统进行`实时监控`，发现并解决性能瓶颈，不断调优系统架构和代码实现。






























```