
# 前端监控平台
## 介绍一下架构
- 多平台、可拓展、可插拔
- 公共库包 -> 不同平台（wx、h5、pc）-> 独立仓库 -> 功能目录进行增删改
- 为什么要这样设计？
  - 引用api的不同 -> 独立 -> 减少打包体积
  - 公共库 -> 统一公共方法（错误id的生成）
## 异常隔离
- try-catch | jest -> 定位和保证
## 上报优化的降级上报机制
- beacon Api -> 不阻塞 && 不需要响应
## 会话级别的错误上报去重
- 错误栈堆 -> hash -> 临时变量 -> 一个用户一个记录 -> 服务端id处理去重
## 缓存命中率的监控
- performance -> resouce -> 遍历 -> 字段判断
- 插曲 问题 -> 获取 请求耗时/内容下载耗时 -> 跨域问题 `（Timing-Allow-Origin）` 
- 兼容考虑 
- 后续 需求 -> 内存缓存 -> back/forward cache -> 渲染监控
- bf cache兼容性的考量 -> safari/火狐/Chrome -> try-catch

# 实习难点亮点
- 
- 实际上整个实习过程中是没有什么说特别难的，因为做很多东西都是有迹可循的，可以去借鉴的
- 但是就最近做的特殊情况下首屏计时的问题，是自己比较感兴趣，主动承担的去做的
- 背景就是通过performance面板录制发现这边对于大量Echarts和threejs这种使用 performance api计时不够准确
- lcp失效了，需要手动去进行确切的监控，必须满足 2.5s内的体验时机，所以要确定几个事情

- 怎么监听？
  - 很明显有比较适合的 api ，MutationObserver去进行监听，但是它不能知道什么时候绘制完成，我们只能在每次它Dom改变的时候进行执行回调函数去判断是否可以去进行上报了，但是每次变化又实在太多函数同时进行了
- 希望性能上不要太差，怎么尽量减少对页面的影响？
  - 防抖
- 什么时候开始去上报？
  - 无论怎么样还是需要去进行下载和绘制的，我们可以去对 `DOMContentLoaded`事件、`Lcp`事件的结束获取到他们的状态，然后就可以进行上报了
- 实际上基本都做完了，但是针对这个DOM如果不在首页呢？还是需要去，先去判断一下
- 但是发现还是和录制的结果有差异，会在绘制之前就进行上报，那实际上就是`lcp`的时机不够准确
- 那怎么去进行更精细的统计，主要矛盾就在这绘制的一帧上的问题，因次考虑去用到这个`requestAnimationFrame()`里面调用`performance.now()`
- 还得减去防抖的时间

# threejs优化
- 背景：大量Echarts
- 优化的角度：
  - 业务方，产品方的允许的方案（要有割舍）、出具体的方案来进行讨论
- 矛盾点在于
- 


# 脚手架
- 为什么做这个事情？
  - 因为整车部门很多项目都是一样的、类似的，为了节省后续搭建系统的成本，于是需要一个脚手架和文档来进行快速搭建
- 是什么？完成了什么？
  - PC端、h5端、uniapp、vue、js、ts、权限管理方案、集成基本的埋点和性能监控的选择
  - 负责把PC端的抽象出来，其中要配合产品、后端、Ui来实现整个功能
  - 具体完成的事情：
    - 为了兼容大系统，我们一是进行了传统token的权限管理方式
    - 二是搭建新系统，且权限管理不复杂，我们采取 JWT 的方式进行权限管理

- 背景
  - 为什么？  类似 节约成本 根据之前的项目去抽象出来 统一包版本
- 难点？解决的事情？
  - 脚手架本身没有什么难点，核心就是 `gitClone`，借助 `Node.js`的一些包来实现更优雅的管理，后续还可能增加其他类型的项目的抽象
  - 然后我就讲一讲怎么当初完成这个需求前，和后端、产品、mt怎么讲述要点的吧
  - 1. 模板集成基本的代码格式、提交规范和保证兼容性的方法
  - 2. 项目目录的优化
    - 接口前缀的解耦和统一维护：
      - 微服务架构 -> 分开部署 -> 每个模块功能的接口域名前缀基本不同
  - 3. 报表和按钮的鉴权的实现
    - `怎么用传统双token实现？不用 jwt、session？`
    - `jwt/session适合什么场景？`
    - `权限管理的具体实现`
  - 4. 基本的数据的埋点是怎么做的？
    - pv、uv、路由
    - 优化了路由的埋点方式...
    - 解决实际情况下，飞书进入和 pc系统进入的埋点区别
      - 主要是后端进行发送预警信息，而我们讨论不希望直接将 `token`外显，而是给予了一个未过期的`refresh token`的形式发送，再获取真实 token
  - 5. 后端怎么考虑的，实现的？
    - jwt的产生？
    - 



# 怎么优化？前后端的角度
后端优化：
- 数据库索引：`对频繁查询的字段建立索引`，加快数据库查询速度。

- 缓存数据：使用缓存技术（如 Memcached、`Redis`）缓存热点数据，`减少对数据库的访问`，提高响应速度。

- 优化 SQL 查询：避免使用 SELECT *，只选择需要的字段；合理使用 JOIN、WHERE、GROUP BY 等语句优化查询效率。

- `分页`查询：对于大量数据的查询结果，使用分页查询，减少一次性加载的数据量。

- 异步处理任务：将耗时的任务（如邮件发送、文件处理）放入消息队列或者异步任务队列中处理，减少用户请求的等待时间。

- 水平扩展：使用`负载均衡`和`分布式架构`，将流量分散到多台服务器上，提高系统的`并发`处理能力。
周   
- 监控和调优：使用监控工具对系统进行`实时监控`，发现并解决性能瓶颈，不断调优系统架构和代码实现。


## 前端监控SDK
- [前端监控 SDK 的一些技术要点原理分析 - 掘金 (juejin.cn)](https://juejin.cn/post/7017974567943536671#heading-0)
- [一文摸清前端监控自研实践（一）性能监控 - 掘金 (juejin.cn)](https://juejin.cn/post/7097157902862909471#heading-10)
### 讲述要点
- 首先这些检测网页性能的指标（fp,fcp,lcp,cls）都是chrome开发团队提出来的，都是可以通过`PerformanceObserver`来获取，但是可以使用现成的库`web-vitals`,**它会替我们覆盖很多兼容和特殊的场景**
- FMP（首屏渲染时间first meaning paint）==(2.5s)==
- FP: 从页面加载开始到**第一个像素**绘制到屏幕上的时间(**白屏时间**)
- FCP: 从页面加载开始到页面内容的**第一个部分**在屏幕上完成渲染的时间==(1.8s)==
	- 文本、图像、非空白的 `canvas`或者`svg`b
- LCP: 从页面加载开始到最大**文本块或图像元素**在屏幕上完成渲染的时间==(2.5s)==
- CLS: 从页面加载开始和其[生命周期状态](https://link.juejin.cn/?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2018%2F07%2Fpage-lifecycle-api "https://developers.google.com/web/updates/2018/07/page-lifecycle-api")变为隐藏期间发生的所有意外布局偏移的累积分数(==0.1==)
- FID: 首次输入延迟，例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对==交互==作出响应，并实际能够开始处理事件处理程序所经过的时间（==100ms==）
- 当**纯 HTML** 被完全加载以及解析时，`DOMContentLoaded` 事件会被触发，不用等待 css、img、iframe 加载完(**SSR的首屏时间**)
- `DOMContentLoaded` 事件在文档解析完成、但在加载子资源（如图片、样式表、==嵌入==框架等）之前被触发。相比之下，`document.load` 事件在所有资源加载完成后才会触发
- 当整个页面及所有依赖资源如样式表和图片都**已完成加载**时，将触发 `load` 事件
- 首屏渲染时间
	- 背景，通过什么标准
	- 基础版本：load事件即可，SSR版本：DOMContentLoaded事件，异步DOM加载，需要手动去监控
	- 什么情况需要去手动添加：异步加载的车模型
	-  是什么
		- 首屏的渲染时间是指页面已经获取到资源到渲染结束的时间，通常监听`load`事件只可以可获取加载的时间点，因此得自定义计算
	- 解决了什么问题
		  - 怎么知道`DOM`渲染完毕了？
			  - 防抖节省大量资源
		  - 为什么`DOM`显示完毕的时间不对？
			  - 和 performance面板的时间比较有细微出入
			  - 使用`requestAnimationFrame() `回调函数中调用`performance.now() `获取当前时间，作为它的绘制时间
		  - 非首屏的要监控吗？
			  - 开会讨论，延展性：监听img标签下的加载时间
		  - 什么时候进行开始执行监听函数？
			  - 开会讨论，当初的方案是通过数组储存 DOM修改时间，取最大值即可，考虑优化执行，我们会在 Lcp触发之后再进行触发，减少了函数的执行次数
		  - 什么时候上报？
- performance获取到resource去遍历其中获取到得每个静态资源，通过字段的判断来记录是否命中了（duration、transferSize），但是实际上要获取所有的资源来进行记录时间的消耗，经过了错误的排查，跨域的资源是需要进行判断的，能不能获取到timing的信息，兼容之前的接口。
- 实际上还考虑了内存缓存的作用，`bfcache`，它是内存缓存，特点是恢复页面。代码不会执行，我们还监听了相应的渲染内容的，去监听`pageshow`事件即可，这个兼容性还不是特别好，去调研了一翻，只有safari、firfox和高版本的谷歌支持这种形式
		- `Timing-Allow-Origin` 是一个 HTTP 头部响应字段，用于允许浏览器在跨域资源加载时获取性能计时信息。
- 错误监控
	- 使用 `addEventListener()` 监听 error 事件，可以捕获到资源加载失败错误。
	- 使用 `window.onerror` 可以监听 js 错误。
	- 使用 `addEventListener()` 监听 unhandledrejection 事件，可以捕获到未处理的 promise 错误。
	- 利用 `window.onerror` 是捕获不到 Vue 错误的，它需要使用 Vue 提供的 API 进行监听。
- 行为数据监控
	- PV(page view) 是页面浏览量，UV(Unique visitor)用户访问量。PV 只要访问一次页面就算一次，UV 同一天内多次访问只算一次。前端做pv，后端做uv。`那么pv可以做延迟上报，减小请求数，每满足多少发一次`。
	- 停留时长
	- 访问深度
	- 用户点击
	- 页面跳转
- 控制会话级错误
	- 通过uid来进行生成唯一的错误编码，客户端会话级别的上报错误去重，服务端的相同错误的数据聚合
- 上报优化
	- http2 多路复用
	- requestIdleCallback
	- 
### 优化
目前白屏常见的优化方案有：

- SSR
- 预渲染
- 骨架屏

优化首屏加载时间的方法：

- CDN分发（减少传输距离）
- 后端在业务层的缓存
- 静态文件缓存方案
- 前端的资源动态加载
- 减少请求的数量
- 利用好HTTP压缩
# 性能优化
- url -> 显示 -> 链路
- 网络
  - DNS预解析 （用户必经、必须得静态资源） <link>
  - 缓存策略
  - 预加载 <link>
  - Http2.0
  - CDN（内容分发网络）
  - 资源压缩 gzip
  - SSR策略
- 渲染
  - 重绘重排
  - 动画效果 GPU加速
- js
  - idea空闲 
  - web worker 
  - 内存泄漏
- 工程化/组件化
  - 图片、js、css压缩
  - 产物拆包 （vite内置）
  - 组件复用
  - 懒加载组件
  - 懒加载图片
### 架构实现
- [腾讯三面：说说前端监控平台/监控SDK的架构设计和难点亮点？ - 掘金 (juejin.cn)](https://juejin.cn/post/7108660942686126093#heading-3)
- 多平台，可拓展，可插拔
	- 可以支持多平台：包括微信小程序，h5，node.js
	- 设置项目架构：可拓展，可插拔（不同功能业务之间可以相互剥离），主要是实现继承的方式实现公共库（上报方式上/监控函数上...）,不同平台上不同的业务代码，进行分开打包和发布。
![[Pasted image 20240202212759.png]]
- 怎么理解**可支持多平台、可拓展、可插拔式架构**
	- 目前的业务范围是包括了 h5和 pc端的内容，基于的前端框架也可以不同
	- 然而 h5端目前需要监控的内容所需要的功能没那么多，并且有些监控的功能是需要和 pc端的区分开
		- 比如首屏的判断...使用的这块主要是 pc的，所以其他的没怎么了解
	- 可拓展、可插拔
		- 公共库（生成错误 id等）都继承，这样可以方便维护和统一某些功能
		- 每个平台分开打包，体积减小
		- 每个功能都是一个插件，可以拓展也可以移除（公共的就都已经维护了）
- 怎么理解**异常隔离、上报优化的降级上报机制和会话级别的错误上报去重**
	- 我们的 SDK是不能出错的，最简单的就是实例化的时候去 `try-catch`包裹
	- 但是我们需要去知道哪个模块出了问题，我们可以在功能函数里去加`try-catch`即可，并且通过 jest用例测评，基本是不会出现拓展后还有发送异常的可能
	- Beacon : **不需要响应**，**不会阻塞**主线程的任务执行，保证页面卸载之前启动请求，适用在一些可以延迟上报的情况（fps、pv、pu）
	- ajax
	- 实际上就是根据错误堆栈进行解析，可以获取某个 `chunk`下哪`行`的`方法`有问题再根据生成`hash`值，我们要实现同一个用户错误上报一次，不同用户的上报同一个错误需要服务端去根据 `id`处理数据




























```