# 常见的content字段
- 数据格式、压缩方式、支持语言、字符集
# 缓存相关
- 强缓存检查、不要请求，检查字段
- 当Expires和Cache-Control同时存在的时候，Cache-Control会`优先`考虑。
  - Expires
  - Cache-Control
    - max-age
    - private：仅在客户端，Nginx 是一个功能强大的代理服务器也不会在其上缓存
    - no-cache：协商
    - no-store: 不缓存
    - s-maxage: 代理服务器上的缓存时间
    - must-revalidate：缓存过期直接去源服务器

- 协商缓存
  - 响应头：Last-Modified
  - 请求头：If-Modified-Since
  - 响应头：ETag
  - 请求头：If-None-Match

# 跨域
- 是什么？
  - 浏览器对于非同源的 `URL`发送请求，产生跨域
  - 本质：沙箱当中的渲染进程 -> 网络进程 -> 主进程 -> 主进程检查到跨域 -> 响应题丢弃 （为什么？）
- 怎么做？
- CORS：跨域资源共享，服务器需要附加特定的响应头
  - Access-Control-Allow-Origin: 表示可以允许请求的`源`
  - Access-Control-Allow-Methods: 表示允许的请求`方法列表`
  - Access-Control-Allow-Credentials: Cookie
  - Access-Control-Allow-Headers: 表示允许发送的`请求头字段`
  - Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条`预检请求`
- 简单请求:
  - 请求方法为 GET、POST 或者 HEAD
  - 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain)
- 预检请求的方法是OPTIONS，同时会加上Origin源地址和Host目标地址，这很简单。同时也会加上两个关键的字段:
  - Access-Control-Request-Method, 列出 CORS 请求用到哪个HTTP方法
  - Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头
- JSONP
  - 返回给script标签，浏览器直接把这部分字符串执行
- 代理服务器

# Cookie
- 是什么？
  - Cookie 本质上就是浏览器里面存储的一个很小的文本文件`（4kb）`，内部以`键值对`的方式来存储
  - 服务端可以通过响应头中的 `Set-Cookie`字段来对客户端写入 `Cookie`
  - 向`同一个域名`下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析
  - 包括的信息
    - 唯一标识用户会话的标识符UID
    - 偏好信息
- 生命周期
  - `Expires`和 `Max-Age`
- 作用域
  - `Domain`和 `path`
- 安全相关
  - HttpOnly
  - SameSite
    - Strict：要求 URL完全一致
    - Lax：`get`方法中可以允许`跨站`时携带
    - None：默认情况
- 缺点：
  - 紧跟域名，每次发送会携带，但可以通过Domain和Path指定作用域来解决
    - 静态资源往往放到非同域名下
  - 容量缺陷
  - 安全缺陷
# localStorage
- 针对一个域名，即在`同一个域名`下，会存储相同的一段localStorage。
- 容量：5MB
- 只留存在客户端：避免了性能问题和安全问题
# sessionStorage
- 会话结束，也就是页面关闭，这部分sessionStorage就不复存在了
- 用途
  - 浏览记录
  - 表单信息的存储

# Hppt2.0
- 性能提升
  - 头部压缩
    - 在 HTTP/1.1 及之前的时代，请求体一般会有响应的压缩编码过程
    - 对于` GET `请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的
  - 多路复用
    - 并发连接和域名分片，只是增加了 TCP 连接 -> 多条 TCP 连接会竞争有限的带宽 ->  二进制分帧 

- 二进制分帧
  - 在数据链路层是通过帧来传输的，提前解析成帧，转换为二进制串，Header + Data的形式
  - 分帧之后，服务器收到的是乱序的二进制帧，不存在先后关系，也就解决了http1.1的队头阻塞的问题
  - 二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文
  - 通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(Stream)。

- 颠覆性功能
  - 设置请求的优先级
  - 服务器推送
    - 新建 stream 来给客户端发送消息
    - 比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中`引用到的其他资源文件`一起返回给客户端，减少客户端的等待
    - 

# CDN（内容分发网络）
- 网站预先内容分发到全国各地的（加速）节点，有效提升下载速度、降低响应时间
- 流程
  - 发送域名
  - DNS服务器返回的不是ip，而是别名指向CDN的全局负载均衡
  - 这个`CDN专用的DNS的服务器`，会根据ip来查看地址等情况
  - 返回最佳的ip

# http发展史

- 请求头
  - accept [期待服务器返回的类型文件] text/html
  - accept-encoding [压缩方式] gzip
  - accept-Charset [文件编码的方式] utf-8
  - accept-language [优先语言]
  - Connection: [默认支持长连接] keep-alive
  - User-Agent：[用户代理字段] Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3
- 响应头
  - content-encoding [最终返回的压缩类型]
  - content-type [文件类型]
- http 0.9
  - 只有get请求
  - 明文ASII码传输
  - 只支持html文件，数据量不够用，要面向国际化，没有响应头，不知道用户的信息

- http 1.0
  - 出现了 post请求，可以增大数据量
  - 状态码解决了请求的情况的问题
  - 引入了缓存机制：Expires、Last-Modified（If-Modified-Since）
  - User-Agent字段表示用户`客户端信息`，
  - 频繁断开，无状态协议（需要会话信息的存储），没有安全机制还是明文传输，动态生成的内容不知道长度

- http 1.1
  - Connection: [默认支持长连接] `keep-alive`
  - cookies 应运而生
  - HTTP/1.0 中引入的 Host ，虚拟机问题，一个服务器可能会承载多个域名的网站
  - 最后使用一个`零长度`的块作为发送数据完成的标志。这样就提供了对动态内容的支持
  - 浏览器为每个域名最多同时维护 `6个TCP连接`
  - put delete option
- http 2.0
  - 一个域名只使用一个 TCP 长连接和`消除应用层传输协议的队头阻塞问题`，HTTP/2 最核心、最重要且最具颠覆性的`多路复用机制`
  - 举个简单的例子，当客户端需要向服务器发送一个`较大的HTTP POST请求`时，这个HTTP消息可能会被分割为多个数据帧（DATA Frame），每个数据帧携带部分请求体数据；同时，还会有一个`头部帧`（HEADERS Frame）携带请求的头部信息。这些帧一起构成了完整的HTTP消息，在传输过程中被`交错发送`，最终在`服务器端``重新组装`成完整的HTTP消息进行处理。
  - 能直接拿到需要的` CSS `文件和` JavaScript `文件
  - 首部压缩，有效降低了请求头不压缩浪费的资源
  - 服务器推送，（顺便）主动推送相关的静态资源
- http 3.0
  - QUIC

# TCP的keepalive
-  它的作用就是`探测`对端的连接有没有失效,检测`长时间`的死连接
-  现状是大部分的应用并没有默认开启 TCP 的keep-alive选项
-  7200s 也就是两个小时检测一次，时间太长

# TCP流量控制
- 三次握手，`初始化`发送和接收窗口的大小，均为200字节
- 当前发送端给接收端发送 100 个字节，发送端的`可用窗口`减少了 100 个字节，`往后移动`
- 这 100 个到达了接收端，被放到接收端的`缓冲队列`中，`大量负载`
- 只能处理 40 个字节，剩下的 60 个字节被`留`在了缓冲队列
- 接收端会在 `ACK` 的报文首部带上缩小后的滑动窗口 140 字节
- 
# TCP拥塞控制
- 刚开始进入传输数据的时候，你是`不知道现在的网路到底是稳定还是拥堵的`，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。因此，拥塞控制首先就是要采用一种`保守`的算法来慢慢地适应整个网路，这种算法叫`慢启动`
  - 三次握手，宣告接收窗口的大小
  - 初始化拥塞窗口`cwnd`的大小
  - 起初每增加一个ACK，拥塞窗口增二，到了`慢启动阈值`
  - TCP传输过程中丢包了，接收端发现数据段不是按序到达的，而是重复的`ACK报文`，马上进行`快速重传和选择性重传`
  - 快速恢复，拥塞阈值降为一半
- 拥塞窗口是指目前`自己还能传输`的数据量大小
# TCP三次握手为什么不是两次
- 无法确认客户端的接收能力。

# 为什么是四次挥手而不是三次？
- 第四次挥手，主动关闭端等待2MSL是必须的
- 要使得服务端知道它最后发出的Fin报文成功了
- 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?
  - 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
  - 1 个 MSL 确保对端没有收到 ACK `重传`的 FIN 报文可以到达
# 跨站脚本攻击
- 存储型
  - 评论区 -> 数据库
- 反射型
  - URL -> 反射到HTML文档中执行
- 劫持文档型
  - 数据包篡改
- 转义、过滤
- CSP浏览器的内容安全策略：核心思想就是服务器`决定`浏览器加载哪些资源
# 跨站请求伪造
- 陌生网页，诱导点击，自动发送请求，携带cookie（前提是已经登录过）
- 

● window.onload 事件会等待页面所有资源加载完成后才触发，因此可能会导致页面加载速度较慢。
● document.ready 事件只等待 HTML 文档加载完成后就触发，不需要等待其他资源加载完成
● `eventTarget` 指向`实际`目标元素，`currentTarget` 指向事件`绑定`的元素，如果不阻止事件冒泡，eventTarget 的值可能会随着事件冒泡而改变。
● HTTPS握手涉及"多次握手"，但实际上这包括了TCP的三次握手和TLS/SSL握手的多次消息交换。TLS/SSL握手本身不是简单的一次握手过程，而是一个包含了多个回合的协议谈判过程。

