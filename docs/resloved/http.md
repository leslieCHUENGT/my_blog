# 跨域
**讲一下跨域是啥**
- 跨域本质就是**浏览器**基于**同源策略**的一种安全的手段，跨域是对浏览器的限制。同源策略呢，是浏览器核心的安全功能。
- 同源策略呢，三个相同，协议、主机、端口相同。当有一个不同了，就会产生跨域问题。

**跨域拦截是浏览器拦截还是服务器拦截**
- 基于同源策略，浏览器发现是非同源的资源，浏览器会把响应体丢弃
- 所以能发出请求，服务器也会正常响应，只不过结果被浏览器拦截了

**假设我现在在淘宝，要去百度，我还会携带上淘宝的cookie吗**
- 不会，在`cookie`中，`domain`属性指定了`cookie`的所属域名和其下的子域名共享，`path`属性来指定路径，其他路径则无法获取
- 子域名就是指以**example.com 作为后缀**的所有域名，`blog.example.com` 等都属于 `example.com `的子域名。
- 这两个属性决定了服务器发送是否会带上这个cookie

**淘宝跳转到天猫页面为什么不需要重新登陆( taobao.com 和 tmall.com )**
- 这个应该是和服务器端`session ID`和`token`有关
- 当登录时发送请求到服务器，服务器创建`session ID`和`token`,会返回它作为`cookie`的一部分
- 点击跳转的时候根据这个包含`session ID`和`token`的`cookie`和服务器端的进行验证即可

**如何解决呢**
- `vue`全栈项目里我是用的最多的是`CORS`跨域，也就是跨域资源共享，它是一系列http头组成的
- 实质就是在后端服务器增加一些特点的响应头信息
- 通过设置响应头`Access-Control-Allow-xxx`字段来设置访问的**白名单**、**可允许访问的方式**等
- 比较常见的有
  - Access-Control-Allow-Origin `'host'`可以设置白名单
  - Access-Control-Allow-Headers `'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'`
  - Access-Control-Allow-Methods `'PUT, POST, GET, DELETE, OPTIONS'`

- 还有就是通过proxy来实现跨域
- 它的本质就是通过绕开浏览器的同源策略限制来实现的
- 一是可以通过`webpack`的`devServer`来配置`proxy`进行代理
- 二是通过`nginx`实现代理

- 还有是一个`html5`原生的`websocket`也可以进行跨域
- `WebSocket` 是一种在单个`TCP `连接上进行双向通信的协议。与 `HTTP` 不同的是，`WebSocket` 在建立连接后，客户端和服务器之间可以直接发送消息，而不需要像 `HTTP` 一样每次请求都需要建立新的连接。
- 要实现 `WebSocket` 跨域服务，要向 `CORS` 一样设置允许特定域名的跨域请求才行

- 最后我还了解了jsonp来实现跨域
- 返回的数据会被当做`JavaScript`代码执行
- 浏览器对于` <script>` 标签的请求不受同源策略限制的特性。
- JSONP只支持`GET`请求，无法支持`POST`等其他类型的请求。
  - jsonp引发的恶意攻击：
  - XXS与CFRS攻击
  - 数据泄漏

**讲讲跨域中怎么携带cookie**
- 后端设置响应头`Access-Control-Allow-Credentials`为`true`，表示允许浏览器发送包含身份凭证的请求，比如cookie、授权标头。
- 在前端发送请求时，需要设置 `withCredentials` 为 `true`，表示可以发送包含身份凭证的请求。
- 都必须使用`https`协议



# nginx
**讲一下nginx的反向代理**
- 反向代理服务器充当了一个中间人的角色
- 输入网站访问服务器的时候，会先通过http或者https协议发送到反向代理服务器
- nginx根据配置呢，把请求转发到后端服务器上面
- 响应返回给nginx服务器，nginx服务器转发响应给客服端

**负载均衡**
- 定义了后端服务器集群，其中包含多少台Web服务器
- 一个挂了就可以转发给另一个
- 就可以实现负载均衡

# XXS攻击
**讲一下什么是XXS攻击**
- 叫**跨站脚本**攻击
- 分为三种情况
  - **存储型**、**反射型**和**文档型**
- 存储型比较常见的例子就是评论去输入一段脚本代码，没做转义和过滤等操作，就会存储到数据库里，页面渲染过程中直接执行。
- 反射型比较常见的就是脚本代码作为网络请求的一部分，经过服务器，反射到html文档里，执行
- 文档型是在数据传输过程中劫持数据包，修改里面的html文档

**怎么防范XXS攻击呢？**
- 一个信念，两个利用
- 千万不要相信用户的任何输入，必须经过**转义**和**过滤**
- 利用`CSP`安全机制，核心思想就是服务器决定浏览器加载哪些资源
- 利用`HttpOnly`
  - 很多 XSS 攻击脚本都是用来窃取`Cookie`, 而设置 `Cookie` 的 `HttpOnly` 属性后，`JavaScript` 便无法读取 `Cookie` 的值。这样也能很好的防范 `XSS` 攻击。

# CFRS攻击
**讲一下什么是CSRF攻击**
- `即跨站请求伪造`
- 比较常见的有黑客诱导用户点击链接，那么就打开了黑客的网站，黑客就**利用用户目前的登录状态**发起跨站请求
- 然后就可能做下面几件事
- 1是自动发get请求，这个请求会带上之前你已经登录过的网站的cookie，然后进行操作，获取信息、转账汇款
- 2是自动发post请求，写了一个自动提交post请求的脚本，恶意操作
- 3是诱导点击发送get请求，流程大差不大
- CSRF攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，**利用`服务器的验证漏洞`和`用户之前的登录状态`来`模拟用户进行操作`。**

**怎么防范CFRS攻击**
1. 利用`Cookie`的`SameSite`属性
   - strict模式，完全禁止第三方请求携带，完全遵守同源策略
   - lax模式，get提交的时候可以携带
   - none模式，自动携带
2. 验证来源站点，请求头中的两个字段，Origin(域名)和Referer(URI)，但是可以伪造啊
3. CSRF Token令牌，在每个表单提交中都包含一个随机生成的令牌

# Cookie、Session、Token、JWT
- Authentication是验证当前用户的身份
- Authorization用户授予第三方应用访问该用户某些资源的权限
- Credentials实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份

**什么是cookie**
- `http`是无状态的协议，对于每次的事务处理是没有记忆能力的，结束会话就不会保存任何会话信息
每个请求都是独立的，**为了进行会话跟踪**，就需要去维护一个状态
这个状态可以通过`cookie`或者`session`实现
- `cookie`存储在客服端上，一般不能超过4kb
- `cookie`比较重要的属性：
  - `domain`、`path`(跨域问题)
  - `httpOnly`可以禁止`js`获取`cookie`防范`XSS`攻击，但是可以在`application`手动修改获取
  - `maxAge`(设置时间)
  - `secure`当 secure 值为 `true` 时，cookie 在 HTTP 中是无效，在 `HTTPS` 中才有效。
- 怎么生成的？发来请求，服务器就在响应头设置set-Cookie，指定了什么内容要放到cookie里，再发送就发请求头的cookie

**什么是session**
- `session`是另一种记录服务器和客服端**会话状态**的机制
- **会话信息**可以包括**用户身份验证状态、购物车内容、搜索历史记录以及其他与用户交互相关的数据。**
- `session`可以存储的数据远高于`cookie`
- `session`是基于`cookie`实现的，`session`存储在服务器端，`session ID`会被存储到客服端的`cookie`中
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8db049ca37343cda1fd37fde7c47e33~tplv-k3u1fbpfcp-watermark.image?)

**他们两个的区别**
- 安全性：`session`更安全
- 存取值的类型不同：`Cookie` 只支持存**字符串数据**，想要设置其他类型的数据，需要将**其转换成字符串**，`Session` 可以存任意数据类型。
- 有效期不同：cookie可长时间，session一般在**客服端关闭了**就失效了
- 存储量：4kb，...

**什么是Token**
- **`Token`是指身份验证的令牌**，一般指`Access Token`比如当用户登录后，**服务器**会生成一个`token`发送给客服端，它包含一些加密的信息，后续请求中`验证`客服端用户的身份
- 后续的请求中，客服端会把这个`token`作为**请求头的一部分**
- `token`完全由应用管理，所以他可以避开同源策略
- 还有一种`token`叫做`Refresh Token`
- 它是专门用来刷新access token的token
- 举个经典的例子，当用户登录发送请求，服务器会加密生成token返回给客服端，
- 当然，我这里举的例子是当`token`存储在`cookie`或者`localStorage`里的，这个`token`里有`access Token`和`Refresh Token`
- `Refresh Token`的有效期是比较长的，当`access Token`过期，而它没过期，那么服务器端会返回新的`access Token`和`Refresh Token`
- 也就不需要重新登录了
- `Access Token`和`Refresh Token`可能会被存储在**服务器端的数据库中**

**讲一讲session和Token的区别**
- session是记录服务器端和客服端会话状态的机制，Token是指验证身份的令牌
- session和token并不矛盾，各司其职
- 他们可以一起进行用户信息的验证，登录操作时，服务器会返回带有session ID和token的cookie

**什么是jwt**
- JSON Web Token
- 非对称加解密

**jwt的原理**

**JWT 的使用方式**
- "Bearer" 是一种**认证机制中的一种类型**
  ```js
  Authorization: Bearer <token>
  ```
- 客户端收到服务器返回的 `JWT`，可以储存在 `Cookie` 里面，也可以储存在 `localStorage`
- 所以更好的做法是放在 `HTTP` 请求头信息的 `Authorization` 字段里，使用 `Bearer` 模式添加 `JWT`。

**Token 和 JWT 的区别**
- Token：要**查询数据库获取用户信息**，然后验证 `Token` 是否有效。
- JWT：减少查询数据库操作，因为 `JWT` 自包含了用户信息和加密的数据。

**使用cookie时应该注意的问题**
- 安全角度：存在本地客户端，可以被篡改，需要检查合法性，httpOnly只能是稍微提高了点安全性
- 使用角度：设置正确的domian和path，防止cookie外泄，cookie也不能太大

**使用 session 时需要考虑的问题**
- session存储在服务器，占用服务器资源，又要定期清理过期的session
- session基于cookie实现，要考虑cookie跨域问题
- 当然sessionId可以在url参数后面重写url或者在请求头里添加自定义的header，不基于cookie也其实可以实现

**使用token时需要考虑的问题**
- 会用到数据库查询，可能会导致查询时间长。
- token 可以避免 CSRF 攻击，(因为不需要 cookie 了)



# HTTPS

**HTTPS为什么会出现**
- http是**明文传输**，容易被截取、修改和伪造请求发送
- http不会验证通信方的身份，**没有用户验证**
- http传输过程中**不会验证报文的完整性**，保证不了**数据一致性**

**什么是HTTPS**
- HTTPS 是 HTTP 协议的一种扩展，它本身并不保证传输的证安全性
- **传输层安全性**`(TLS)`或**安全套接字层**`(SSL)`对通信协议进行加密。也就是 `HTTP` +` SSL(TLS)` = `HTTPS`。
- 原理是`HTTP`和`TCP`之间建立了一个**安全层**，安全层的核心就是加解密
- HTTPS默认使用**服务器**的`443`端口


**对称加密和非对称加密**
- 对称加密：加密和解密时使用的密钥都是同样的密钥，比如位运算。速度快
- 非对称加密也被称为公钥加密，比如特定的曲线方程和基点生成公钥和私钥。速度慢

**讲讲HTTPS加解密的流程吧**

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a912ac78bcbc4270888d418e6eaa520d~tplv-k3u1fbpfcp-watermark.image?)

1. 用户发起`HTTPS`请求,和服务器的`443`端口连接
2. `HTTPS`收到请求，返回响应，响应包括`CA`证书、证书里面有公钥`Public`，私钥`Private`保留在了服务器，不公开
3. 客服端收到证书，校验合法性，主要包括：是否有限期内、证书的域名和请求的域名是否匹配、颁发机构，合法则继续下面的流程
4. 客服端会用证书里的公钥加密一个`key`，发送给服务端
5. 服务端收到这个`key`，会用私钥解密，然后再对`key`进行对称加密，响应返回给客户端
6. 客户端使用对称解密这个`key`
7. 这个时候客户端和服务器端都有了这个`key`的真实值，后续请求就用对称加解密来相互验证就可以了
总结：对称加解密和非对称加解密混合，结合证书验证。


# 浏览器架构
- 并行处理就是采用多线程处理任务
- **进程启动和管理线程**，进程就是程序的**运行实例**
- 本质来讲进程是**运行的环境**，操作系统会开创一块内存来存放代码，数据和文件
- 进程的任意线程出错，那么整个进程崩溃，参考原始的IE
- 线程是可以共享进程的数据的
- 进程退出，操作系统就会回收内存
- 进程和进程之间相互隔离，靠IPC通信

**为什么单进程浏览器时代存在不稳定、不流畅和不安全的问题**
- 插件和渲染引擎模块容易崩溃
- 渲染的线程，只有一个模块可以执行，插件也可能会出现问题啊
- 插件可以获取进程的资源，浏览器本身有些功能是需要对接到操作系统的，比如文件下载等，利用漏洞来恶意操作

**目前多进程架构**
- 有五类进程
- 浏览器主进程：负责界面显示、交互、存储
- 渲染进程：运行在沙箱模式下，这个模式下的进程不可以对硬盘写入数据，不能在敏感位置读取数据。因为这个进程的核心任务是将HTML、CSS和javascript转化成可以交互的页面，可以存在跨站脚本攻击XSS，它可以禁止进程访问用户的cookie，限制对其他网站的访问，减少了CSFR攻击。
- GPU进程：为了实现3D CSS和UI界面的绘制
- 网络进程
- 插件进程

# TCP/IP 是如何工作的
**互联网，实际上是一套理念和协议组成的体系架构。都遵守一套协议，那么网络通信将会畅通无阻。**
- IP(Internet Protocol)网际协议
- 也就是计算机的地址，访问任何网站也不过是从一台计算机到另一台计算机请求信息
- 数据包要有IP头
- IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

- UDP(User Datagram Protocol)用户数据包协议
- 通过计算机上的端口号来把数据包发送给指定的程序
- 所以数据包又多了一个头
- UDP不能保证数据的完整性，因为对于错误的包，它直接丢弃，传输速度是非常快的

- TCP（Transmission Control Protocol，**传输控制协议**）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
- TCP 头除了包含了目标端口和本机端口号外，**还提供了用于排序的序列号，**以便接收端通过序号来重排数据包。
- 一个完整的 TCP 连接的生命周期包括了“**建立连接**”“**传输数据**”和“**断开连接**”三个阶段。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b5168e7b674065b03d011ff88080bf~tplv-k3u1fbpfcp-watermark.image?)

- 其中，传输数据阶段。接受端需要对每个数据包进行确认操作。
- 也就是说收了数据包，得回信，不然就算是数据包丢失，就触发了重发机制
- 小包传过去就可以用头信息的序列号来排序

# HTTP请求流程

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2e2d74b8487433aa2034becafed3882~tplv-k3u1fbpfcp-watermark.image?)

如果你在浏览器地址栏里键入极客时间网站的地址：
1. 构建请求，
2. 查找缓存，先看看缓存的生存期到没到期
3. 准备IP地址和端口
  - 这个时候通过DNS来返回域名对应的IP，DNS也有缓存的
  - 建立TCP连接需要计算机程序的端口号，起始的和最终的
  - http是在80端口
4. 等待TCP队列，一个域名下可能存在的TCP连接大于6个，就需要排队
5. 建立TCP连接
  - 三次握手确定连接
6. 发起HTTP请求

**为什么很多站点第二次打开速度会很快？**
- DNS 缓存和页面资源缓存

# 从输入URL到页面展示，这中间发生了什么？

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9f72d3b73fa441f94fd089b1110a803~tplv-k3u1fbpfcp-watermark.image?)

1. 用户输入url并回车
2. 浏览器进程检查url，组装协议，构成完整的url
3. 浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
4. 网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
5. 如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
  5.1 进行DNS解析，获取服务器ip地址，端口
  5.2 利用ip地址和服务器建立tcp连接
  5.3 构建请求头信息
  5.4 发送请求头信息
  5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
6. 网络进程解析响应流程；
  6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步，如果是200，则继续处理请求。
  6.2 200响应处理：
    检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
    后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
7. 准备渲染进程
  7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
8. 传输数据、更新状态
  8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
  8.2 **渲染进程接收完数据后，向浏览器发送“确认提交”**
  8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。

# 讲一讲复杂的渲染流程
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7636bf798be48e59df3a356ebe35f8a~tplv-k3u1fbpfcp-watermark.image?)

1. **渲染进程接受完数据之后，先把html内容转换为DOM树**(document)
2. **渲染引擎将html内容里的css内容转换为styleSheets**(document.styleSheets)，还会把属性值标准化，比如rem转换为px，**计算DOM节点的样式**，把不显示在页面的DOM去掉。设置为display:none的节点，会存在在DOM树里，但是v-if不会。
3. **创建布局树，计算元素、节点的布局信息**
4. **对布局树进行分层，生成分层树。**页面元素是按照嵌套关系组织的，生成分层树，使得渲染更加高效
5. **对每一个图层生成绘制列表，并提交到合成线程中。**绘制列表只是用来记录绘制顺序和绘制指令的列表，际上绘制操作是由渲染引擎中的合成线程来完成的。
6. **合成线程将图层会分成图块，并在光栅化线程池中将图块转换成位图。**合成线程会将图层划分为图块（tile），这些图块的大小通常是 `256x256` 或者 `512x512`,合成线程会按照**视口**附近的图块来**优先**生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图.位图（bitmap），也叫做**光栅图或像素图**，例如，当浏览器将网页中的 `SVG` 图片或 `Canvas` 元素渲染成屏幕上可视的元素时，会使用光栅化技术将其转换为位图。位图可以直接在屏幕上显示，而不需要进行额外的计算，因此它们是一种非常高效的图像呈现方式。栅格化过程都会使用 `GPU` 来加速生成，使用 `GPU` 生成位图的过程叫**快速栅格化**，或者 `GPU` 栅格化，生成的位图被保存在 `GPU` 内存中。这就涉及到了跨进程操作。
7. **合成线程发送绘制图块命令 DrawQuad 给浏览器进程。**
8. **浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。**浏览器进程里面有一个叫 `viz` 的组件，用来接收合成线程发过来的` DrawQuad `命令，然后根据` DrawQuad `命令，将其页面内容绘制到**内存**中，最后再将内存的绘制内容显示在屏幕上。

`CSS`的`transform`属性可以用来对元素进行**平移、旋转、缩放等变换**。由于`transform`**只涉及到视觉呈现的变化，而不会引起文档流的改变，**因此在使用`transform`实现动画效果时，可以避开重排和重绘阶段，从而提高页面性能。
相比之下，通过改变元素的位置、大小等属性来实现动画效果，会导致文档流的改变，引起重排和重绘的发生。这些操作需要重新计算布局，并重新绘制页面元素，所以会比使用`transform`产生更大的性能开销。
因此，在实现动画效果时，尽可能使用`transform`属性，可以有效地减少页面的重排和重绘次数，提高页面的性能。





