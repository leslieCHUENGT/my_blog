# 数组中常见的api
- push() - 将一个或多个元素添加到数组的末尾，并返回新数组的长度。
- pop() - 删除数组的最后一个元素，并返回该元素的值。
- shift() - 删除数组的第一个元素，并返回该元素的值。
- unshift() - 将一个或多个元素添加到数组的开头，并返回新数组的长度。
- slice() - 返回数组的一部分，从开始位置到结束位置（不包括结束位置）。
  - slice() 方法用于返回数组的一部分，它**不改变原始数组**，而是**返回一个新的数组**。该方法接受两个参数：起始位置和结束位置（不包括结束位置）。例如，`arr.slice(1, 3)` 将返回从索引 `1` 开始，到索引 `3`（不包括）的元素，也就是 `arr[1] 和 arr[2]。`
- splice() - 从数组中添加或删除元素，并返回被删除的元素。
  - splice() 方法接受三个参数：**起始位置(从0开始)**、要删除的元素**数量**和可选的要添加到数组中的新元素。**改变原始数组，并返回被删除的元素**
- concat() - 连接两个或多个数组，并返回结果数组。
- join() - 将数组的所有元素连接成一个字符串，并返回该字符串。
- filter() - 创建一个新数组，其中包含满足指定条件的所有元素。
- forEach() - 对数组中的每个元素执行指定操作。
- map() - 创建一个新数组，其中包含对原始数组的每个元素进行指定操作后的结果。
- reduce() - 对数组中的所有元素执行指定的累加器函数，并返回累加器的结果。
- every() - 检查数组中的所有元素是否满足指定条件。
- some() - 检查数组中是否存在至少一个元素满足指定条件。
- indexOf() - 返回指定元素在数组中第一次出现的位置，如果未找到则返回 -1。
- lastIndexOf() - 返回指定元素在数组中最后一次出现的位置，如果未找到则返回 -1。
- sort() - 对数组进行排序，并返回排序后的数组。
- includes() - array.includes(searchElement, fromIndex)它用于判断一个数组是否包含某个特定元素，并返回一个布尔值。
应用场景：数组去重
```js
let arr = [1,2,2,3,4,4,5];
let uniqueArr = arr.reduce((acc, curr) => {
    if (!acc.includes(curr)) {
        acc.push(curr);
    }
    return acc
}, []);
```
# 闭包
**什么是闭包？**
- 一般来讲就是一个`内层函数`中`访问`到其`外层函数的作用域`这种`组合` 
- 柯里化，防抖节流，缓存实现记忆化
- 私有变量

# CommonJS 和 ES6 模块化
- 在引用时的行为是不同的
- 在 `CommonJS` 中，模块加载是同步进行的。 `ES6` 模块化中，模块加载是异步进行的。


# 变量提升
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2621ba19760e40f0aa57eb70c3a66ff4~tplv-k3u1fbpfcp-watermark.image?)

- js这门语言的执行机制是先编译、再执行
- 在编译阶段，变量和函数会被存放到变量环境里，变量的默认值是undefined
- 在代码执行阶段，js引擎会从变量环境里查找变量和函数
- 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。

# 调用栈

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2ea80d923e430c8cdbd54c5e8ffa5f~tplv-k3u1fbpfcp-watermark.image?)
- 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，
- 然后 JavaScript 引擎开始执行函数代码。
- 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
- 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

# 块级作用域
块级作用域就是通过**词法环境的栈结构**来实现的，而变量提升是通过**变量环境**来实现，通过这两者的结合，JavaScript 引擎也就同时支持了**变量提升**和**块级作用域**了。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b00f2cede1364f1789f5f1bf004c3d0a~tplv-k3u1fbpfcp-watermark.image?)

# 作用域链和闭包
- 变量是通过作用域链来查找
- 作用域链是由词法作用域决定的
- 词法作用域由代码中函数声明的位置来决定的，通过它就能够预测代码在执行过程中如何查找标识符。

**闭包的理解**
关于闭包的概念：
老师提出的概念：内部函数引用外部函数的变量的集合。
高级程序设计中的概念：闭包是指有权访问另一个函数作用域中的变量的函数。
MDN上的概念：闭包是函数和声明该函数的词法环境的组合。

- 回答到：在js中，根据词法作用域的规则，内部函数总是可以访问其外部函数声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然报错在内存中，就把这些变量的集合称为闭包，比如外部函数是foo，那么这些变量的集合就称为foo函数的闭包。











