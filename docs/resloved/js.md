# 数组中常见的api
- push() - 将一个或多个元素添加到数组的末尾，并返回新数组的长度。
- pop() - 删除数组的最后一个元素，并返回该元素的值。
- shift() - 删除数组的第一个元素，并返回该元素的值。
- unshift() - 将一个或多个元素添加到数组的开头，并返回新数组的长度。
- slice() - 返回数组的一部分，从开始位置到结束位置（不包括结束位置）。
  - slice() 方法用于返回数组的一部分，它**不改变原始数组**，而是**返回一个新的数组**。该方法接受两个参数：起始位置和结束位置（不包括结束位置）。例如，`arr.slice(1, 3)` 将返回从索引 `1` 开始，到索引 `3`（不包括）的元素，也就是 `arr[1] 和 arr[2]。`
- splice() - 从数组中添加或删除元素，并返回被删除的元素。
  - splice() 方法接受三个参数：**起始位置(从0开始)**、要删除的元素**数量**和可选的要添加到数组中的新元素。**改变原始数组，并返回被删除的元素**
- concat() - 连接两个或多个数组，并返回结果数组。
- join() - 将数组的所有元素连接成一个字符串，并返回该字符串。
- filter() - 创建一个新数组，其中包含满足指定条件的所有元素。
- forEach() - 对数组中的每个元素执行指定操作。
- map() - 创建一个新数组，其中包含对原始数组的每个元素进行指定操作后的结果。
- reduce() - 对数组中的所有元素执行指定的累加器函数，并返回累加器的结果。
- every() - 检查数组中的所有元素是否满足指定条件。
- some() - 检查数组中是否存在至少一个元素满足指定条件。
- indexOf() - 返回指定元素在数组中第一次出现的位置，如果未找到则返回 -1。
- lastIndexOf() - 返回指定元素在数组中最后一次出现的位置，如果未找到则返回 -1。
- sort() - 对数组进行排序，并返回排序后的数组。
- includes() - array.includes(searchElement, fromIndex)它用于判断一个数组是否包含某个特定元素，并返回一个布尔值。
应用场景：数组去重
```js
let arr = [1,2,2,3,4,4,5];
let uniqueArr = arr.reduce((acc, curr) => {
    if (!acc.includes(curr)) {
        acc.push(curr);
    }
    return acc
}, []);
```
# 闭包
**什么是闭包？**
- 一般来讲就是一个`内层函数`中`访问`到其`外层函数的作用域`这种`组合` 
- 柯里化，防抖节流，缓存实现记忆化
- 私有变量

# CommonJS 和 ES6 模块化
- 在引用时的行为是不同的
- 在 `CommonJS` 中，模块加载是同步进行的。 `ES6` 模块化中，模块加载是异步进行的。


**自己对闭包的理解**
- 我理解的闭包是一种组合、模式。
- 这个组合涉及到js在编译前确定的**词法作用域**。
- 简单来说这个组合就是内部函数引用外部函数作用域的变量。
- 在学习过程中为了可以更好的理解一些常见的功能函数，比如闭包可以用在：
- **创建私有变量**、**延迟执行就像防抖节流**，**记忆化**、**柯里化**等等
- 就也去了解了js这门语言的**执行机制**和**内存模型**，对闭包的用途和**缺点**更了理解了

**那你讲一讲js执行机制**
- 简单来说：js引擎是通过**调用栈**来管理执行的上下文的
- 一个执行上下文又包括：变量环境、词法环境、外部环境和this
- 变量环境是js早期就存在的了，变量提升会发生和存放在变量环境里
- 词法环境是js为了实现块级作用域来增加的，存放`let`和`const`定义的变量
- 外部环境和他们两个就已经可以完成作用域链的构建了
- this则是一个大力神的角色，可以扭转指向，但是也存在一些缺点

**为什么要用栈来管理**
- 执行上下文的创建和销毁都是有顺序的，函数的调用和执行，栈是后进先出的，符合他的要求

**那你讲一下闭包的缺点**
- 容易造成内存泄漏，如果闭包引用的是全局变量
- 那么闭包就会一直存在，就造成了内存泄漏了

**this的坑**
- this的决定是什么，就是谁最后调用这个函数就指向谁，跟函数执行的位置有关
- 严格模式下，this指向window会变成undefined
- 嵌套函数，this不会继承
  - 缓存this
  - 箭头函数

**那你讲一讲从内存模型的角度上分析闭包**
- 在编译的时候，js引擎还会对内部函数做词法扫描
- 判断出存在闭包的组合，本来是存放在变量环境或者词法环境里的变量
- 就会存放在堆内存里，所以我们就可以知道为什么闭包最好不要引用全局变量了




```js
const {
    query: {
        page: pageNumber // es6的重命名,解构出来的page就在外层的词法环境中，重名会报错
    }
} = useRoute()
const page = ref(pageNumber ? parseInt(`${ pageNumber }`, 10) : 1)
```
**那你聊聊对数据是如何存储的，对栈内存和堆内存的理解**
- js的内存模型主要是有三种
- 堆内存、栈内存、代码空间
- 栈内存有比较重要的作用，用来存储执行上下文，所以原始数据类型和对象的引用地址会存放在变量环境或者词法环境里
- 堆内存比较大，存放着引用类型的值

**讲一讲垃圾回收机制**
- js这门语言不像c、c++一样需要去手动释放内存
- 栈内存和堆内存里都会存放变量
- 栈是通过ESP指针向下移动来释放内存的
- 堆是通过新生代垃圾回收器和老生代垃圾回收器来实现的
- 老生代那块，会通过标记清除和标记整理的算法来释放内存，来避免内存碎片的问题
- 新生代那块，不仅会通过算法将对象区域和空闲区域不断反转，来避免内存碎片的问题
- 
- 无论是主副垃圾回收器的策略都是标记-清除-整理三个大的步骤。另外还有新生代的晋升策略（两次未清除的），大对象直接分配在老生代。



JavaScript在新生代和老生代区域采用不同的垃圾回收机制，对于程序的性能有着不同的影响。
对于新生代区域，采用了基于复制算法的Scavenge算法进行垃圾回收，由于其中的对象生命周期比较短暂，大部分对象都很快就会死亡，因此采用复制算法可以有效地避免内存碎片的产生，并且可以较快地进行垃圾回收。这种方式的优点是垃圾回收速度快，在短时间内就可以完成垃圾回收，从而可以更快地完成任务。
而对于老生代区域，一般采用标记-清除算法和标记-整理算法进行垃圾回收，由于其中的对象生命周期比较长，垃圾回收的频率相对较低，但是每次垃圾回收需要处理的对象较多，因此采用标记-清除算法和标记-整理算法能够更好地处理大量的对象，减少内存碎片的产生并更好地利用内存空间，从而保证程序的运行效率。
总的来说，不同的垃圾回收机制在不同的情况下有其自身的优点和缺点。对于新生代区域，采用基于复制算法的Scavenge算法可以快速且有效地进行垃圾回收；而对于老生代区域，采用标记-清除算法和标记-整理算法可以更好地处理大量的对象并保证程序的运行效率。




